# -*- coding: utf-8 -*-
"""Python_Numpy_for_Data_Analysis_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S9fcw-GGp_Q6u2iT_-9AUnq7N5ppztXg
"""

#python numpy

"""**Introduction to Numpy**

Numpy is the most basic and a powerful package for working with data in python.

Because other packages for data analysis (like pandas) is built on top of numpy and the scikit-learn package which is used to build machine learning applications works heavily with numpy as well.

At the core, numpy provides the excellent ndarray objects, short for n-dimensional arrays.

In a ‘ndarray’ object, you can store multiple items of the same data type. It is the facilities around the array object that makes numpy so convenient for performing math and data manipulations.
"""

#Numpy array Creation

# Create an 1d array from a list
import numpy as np
list1 = [0,1,2,3,4]
arr1d = np.array(list1)

# Print the array and its type
print(type(arr1d))
arr1d

#create a 2d array from list
list2=[[4,6,2,8],[7,9,6,1],[12,74,5,36]]
arr2d=np.array(list2)

# Print the array and its type
print(type(arr2d))
arr2d

#Create a 3d array
a_3d_array = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(a_3d_array)

import numpy as np
Z = np.array([[0,0,0,0,0,0],
                  [0,0,0,1,0,0],
                  [0,1,0,1,0,0],
                  [0,0,1,1,0,0],
                  [0,0,0,0,0,0],
                  [0,0,0,0,0,0]])

print(Z.dtype)

"""The key difference between an array and a list is, arrays are designed to handle vectorized operations while a python list is not.

That means, if you apply a function it is performed on every item in the array, rather than on the whole array object.
"""

list1 + 2

# Add 2 to each element of arr1d
arr1d + 2

"""Another characteristic is that, once a numpy array is created, you cannot increase its size. To do so, you will have to create a new array. But such a behavior of extending the size is natural in a list.

You can also pass a list of lists to create a matrix like a 2d array.
"""

# Create a 2d array from a list of lists
list2 = [[0,1,2], [3,4,5], [6,7,8]]
arr2d = np.array(list2)
arr2d

"""You may also specify the datatype by setting the dtype argument. Some of the most commonly used numpy dtypes are: 'float', 'int', 'bool', 'str' and 'object'.

To control the memory allocations you may choose to use one of ‘float32’, ‘float64’, ‘int8’, ‘int16’ or ‘int32’.
"""

# Create a float 2d array
arr2d_f = np.array(list2, dtype='float')
arr2d_f

"""The decimal point after each number is indicative of the float datatype. You can also convert it to a different datatype using the astype method."""

# Convert to 'int' datatype
arr2d_f.astype('int')

# Convert to int then to str datatype
arr2d_f.astype('int').astype('str')

"""if you are uncertain about what datatype your array will hold or if you want to hold characters and numbers in the same array, you can set the dtype as 'object'."""

# Create a boolean array
arr2d_b = np.array([1, 0, 10], dtype='bool')
arr2d_b

# Create an object array to hold numbers as well as strings
arr1d_obj = np.array([1, 'a'], dtype='object')
arr1d_obj

"""you can always convert an array back to a python list using tolist()"""

# Convert an array back to a list
arr1d_obj.tolist()

"""Arrays support vectorised operations, while lists don’t.

Once an array is created, you cannot change its size. You will have to create a new array or overwrite the existing one.

Every array has one and only one dtype. All items in it should be of that dtype.

An equivalent numpy array occupies much less space than a python list of lists.
"""

#size and shape of a numpy array

"""Let’s consider the array, arr2d. Since it was created from a list of lists, it has 2 dimensions that can be shown as rows and columns, like in a matrix.

Had I created one from a list of list of lists, it would have 3 dimensions, as in a cube. And so on.

Let’s suppose you were handed a numpy vector that you didn’t create yourself. What are the things you would want to explore in order to know about that array?
"""

# Create a 2d array with 3 rows and 4 columns
list2 = [[1, 2, 3, 4],[3, 4, 5, 6], [5, 6, 7, 8]]
arr2 = np.array(list2, dtype='float')
arr2

# shape
print('Shape: ', arr2.shape)

# dtype
print('Datatype: ', arr2.dtype)

# size
print('Size: ', arr2.size)

# ndim
print('Num Dimensions: ', arr2.ndim)

#extract specific items from an array

arr2

# Extract the first 2 rows and columns
arr2[:2, :2]

"""Additionally, numpy arrays support boolean indexing.

A boolean index array is of the same shape as the array-to-be-filtered and it contains only True and False values. The values corresponding to True positions are retained in the output.
"""

# Get the boolean output by applying the condition to each element.
b = arr2 > 4
b

arr2[b]

#reverse the rows and the whole array

# Reverse only the row positions
arr2[::-1, ]

# Reverse the row and column positions
arr2[::-1, ::-1]

#represent missing values and infinite

"""Missing values can be represented using np.nan object, while np.inf represents infinite"""

# Insert a nan and an inf
arr2[1,1] = np.nan  # not a number
arr2[1,2] = np.inf  # infinite
arr2

# Replace nan and inf with -1. Don't use arr2 == np.nan
missing_bool = np.isnan(arr2) | np.isinf(arr2)
arr2[missing_bool] = -1  
arr2

#mean, min, max on the ndarray

# mean, max and min
print("Mean value is: ", arr2.mean())
print("Max value is: ", arr2.max())
print("Min value is: ", arr2.min())

# Row wise and column wise min
print("Column wise minimum: ", np.amin(arr2, axis=0))
print("Row wise minimum: ", np.amin(arr2, axis=1))

# Cumulative Sum
np.cumsum(arr2)

#create a new array from an existing array

"""If you just assign a portion of an array to another array, the new array you just created actually refers to the parent array in memory.

That means, if you make any changes to the new array, it will reflect in the parent array as well.

So to avoid disturbing the parent array, you need to make a copy of it using copy(). All numpy arrays come with the copy() method.
"""

# Assign portion of arr2 to arr2a. Doesn't really create a new array.
arr2a = arr2[:2,:2]  
arr2a[:1, :1] = 100  # 100 will reflect in arr2
arr2

# Copy portion of arr2 to arr2b
arr2b = arr2[:2, :2].copy()
arr2b[:1, :1] = 101  # 101 will not reflect in arr2
arr2

#Reshaping and Flattening Multidimensional arrays

"""Reshaping is changing the arrangement of items so that shape of the array changes while maintaining the same number of dimensions.

Flattening, however, will convert a multi-dimensional array to a flat 1d array. And not any other shape.

First, let’s reshape the arr2 array from 3×4 to 4×3 shape.
"""

arr2.reshape(4, 3)

#ifference between flatten() and ravel()

"""There are 2 popular ways to implement flattening. That is using the flatten() method and the other using the ravel() method.

The difference between ravel and flatten is, the new array created using ravel is actually a reference to the parent array. So, any changes to the new array will affect the parent as well. But is memory efficient since it does not create a copy.
"""

# Flatten it to a 1d array
arr2.flatten()

# Changing the flattened array does not change parent
b1 = arr2.flatten()  
b1[0] = 100  # changing b1 does not affect arr2
arr2

# Changing the raveled array changes the parent also.
b2 = arr2.ravel()  
b2[0] = 101  # changing b2 changes arr2 also
arr2

#create sequences, repetitions and random numbers using numpy

"""The np.arange function comes handy to create customised number sequences as ndarray."""

# Lower limit is 0 be default
print(np.arange(5))

# 0 to 9
print(np.arange(0, 10))

# 0 to 9 with step of 2
print(np.arange(0, 10, 2))

# 10 to 1, decreasing order
print(np.arange(10, 0, -1))



"""you want to create an array of exactly 10 numbers between 1 and 50, Can you compute what would be the step value?

Well, I am going to use the np.linspace instead.
"""

# Start at 1 and end at 50
np.linspace(start=1, stop=50, num=10, dtype=int)

"""Similar to np.linspace, there is also np.logspace which rises in a logarithmic scale. In np.logspace, the given start value is actually base^start and ends with base^stop, with a default based value of 10."""

# Limit the number of digits after the decimal to 2
np.set_printoptions(precision=2)  

# Start at 10^1 and end at 10^50
np.logspace(start=1, stop=50, num=10, base=10)

"""The np.zeros and np.ones functions lets you create arrays of desired shape where all the items are either 0’s or 1’s."""

np.zeros([2,2])

np.ones([2,2])

#create repeating sequences

"""np.tile will repeat a whole list or array n times. Whereas, np.repeat repeats each item n times."""

a = [1,2,3] 

# Repeat whole of 'a' two times
print('Tile:   ', np.tile(a, 2))

# Repeat each element of 'a' two times
print('Repeat: ', np.repeat(a, 2))

#generate random numbers

# Random numbers between [0,1) of shape 2,2
print(np.random.rand(2,2))

# Normal distribution with mean=0 and variance=1 of shape 2,2
print(np.random.randn(2,2))

# Random integers between [0, 10) of shape 2,2
print(np.random.randint(0, 10, size=[2,2]))

# One random number between [0,1)
print(np.random.random())

# Random numbers between [0,1) of shape 2,2
print(np.random.random(size=[2,2]))

# Pick 10 items from a given list, with equal probability
print(np.random.choice(['a', 'e', 'i', 'o', 'u'], size=10))

# Pick 10 items from a given list with a predefined probability 'p'
print(np.random.choice(['a', 'e', 'i', 'o', 'u'], size=10, p=[0.3, .1, 0.1, 0.4, 0.1]))  # picks more o's

"""Now, everytime you run any of the above functions, you get a different set of random numbers.

If you want to repeat the same set of random numbers every time, you need to set the seed or the random state. The see can be any value. The only requirement is you must set the seed to the same value every time you want to generate the same set of random numbers.

Once np.random.RandomState is created, all the functions of the np.random module becomes available to the created randomstate object.
"""

# Create the random state
rn = np.random.RandomState(100)

# Create random numbers between [0,1) of shape 2,2
print(rn.rand(2,2))

# Set the random seed
np.random.seed(100)

# Create random numbers between [0,1) of shape 2,2
print(np.random.rand(2,2))

#unique items and the counts

# Create random integers of size 10 between [0,10)
np.random.seed(100)
arr_rand = np.random.randint(0, 10, size=10)
print(arr_rand)

# Get the unique items and their counts
uniqs, counts = np.unique(arr_rand, return_counts=True)
print("Unique items : ", uniqs)
print("Counts       : ", counts)

